# 2.4.3 数据导向的程序设计和可加性
## 练习2.74
Insatiable事业公司是一个高度分散经营的联合公司，由一大批分布在世界各地的分支机构组成。公司的计算机设施已经通过一种非常巧妙的网络连接模式联为一体，使得从任何用户的角度看，整个网络就像一台计算机。当Insatiable公司的总经理第一次试图利用网络能力从各分支机构的文件提取管理信息时，她非常沮丧地发现，虽然各分支机构的文件都被实现为JavaScript里的数据结构，但是它们所用的数据结构各不相同。她立刻招来各个分支机构的经理，开了一个会，希望找到一种策略集成起这些文件，以满足公司总部的需要，同时又能保持各分支机构现有的自治状态。请说明可以如何用数据导向的程序设计技术实现一种策略。作为例子，假定每个分支机构的人事记录都保存在一个独立文件里，其中包含了一集以雇员的名字作为键值的记录。而有关集合的结构却由于分支机构的不同而不同。进一步说，每个雇员的记录本身又是一个集合（各分支机构所用的结构也不同）​，其中包含的信息也在一些作为键值的标识符之下，例如address和salary。特别地：
a.请为公司总部实现一个get_record函数，使它能从指定的人事文件里提取出任何特定雇员的记录。这个函数应该能用于任何分支机构的文件。请说明各独立分支机构的文件应该具有怎样的构造。特别地，它们必须提供哪些类型信息？
b.请为公司总部实现一个get_salary函数，它能从任何分支机构的人事文件中获取某个特定雇员的薪金信息。为使这个操作能工作，这些记录应具有怎样的结构？
c.请为公司总部实现一个函数find_employee_record，该函数需要针对特定的雇员名，到所有分支机构的文件去查找对应的记录，并返回找到的记录。假定这个函数的参数是一个雇员名和一个包含所有分支机构文件的表。
d.当Insatiable购并了一家新公司后，为了能把新增加的人事文件结合到中央系统中，必须对系统做哪些修改？

## 解答
##### a.实现record函数
###### 功能
get_record 函数需要从指定的人事文件中提取某个特定雇员的记录。它应该适用于任何分支机构的文件。
###### 解决方案
各独立分支机构的人事文件需要包含以下内容：
1. 文件的类型信息（类型标签），以便分派到具体的提取函数。
2. 一个统一的接口，用于根据雇员名字查找记录。
##### b.实现salary函数
###### 功能
get_salary 函数需要从任何分支机构的人事文件中提取某个特定雇员的薪资信息。
###### 解决方案
每个雇员的记录需要包含以下内容：
1. 记录的类型信息（类型标签），以便分派到具体的提取函数。
2. 一个统一的接口，用于从记录中提取薪资信息。

##### c.实现find_employee_record函数
###### 功能
find_employee_record 函数需要在所有分支机构的人事文件中查找某个特定雇员的记录，并返回找到的记录。
###### 解决方案
1. 遍历所有的人事文件。
2. 在每个文件中调用 get_record 函数。
3. 如果找到了对应的记录，立即返回。
##### d.修改中央系统
###### 场景
当 Insatiable 公司购并了一家新公司时，需要将新公司的人事文件整合到中央系统中。
###### 解决方案
1. 为新公司的人事文件增加一个新的类型标签。
2. 在查找表中新增类型标签及其对应的规则函数。
3. 确保新公司的人事文件符合统一的接口设计。

##### 额外的rust实现
```rust
pub trait Employee {
    fn get_salary(&self) -> f64;
}
pub trait Branches {
    fn get_record(&self, name: &str) -> Option<Box<dyn Employee>>;
}
pub struct Company {
    branches: Vec<Box<dyn Branches>>,
}
impl Company {
    pub fn new() -> Self {
        Self { branches: vec![] }
    }
    pub fn add_branch(&mut self, branch: Box<dyn Branches>) {
        self.branches.push(branch);
    }
    pub fn find_employee(&self, name: &str) -> Option<Box<dyn Employee>> {
        for branch in &self.branches {
            if let Some(employee) = branch.get_record(name) {
                return Some(employee);
            }
        }
        None
    }
}
fn main() {}
```