# 1.2.6 实例：素数检测
## 练习1.23
本节开始时给出的smallest_divisor函数做了许多无用检查：在检查了一个数能否被2整除后，完全没必要再检查它是否能被任何偶数整除。这说明test_divisor用的值不该是2, 3, 4, 5,6, …，而应该是2, 3, 5, 7, 9, …。请实现这种修改。其中声明一个函数next，用2调用时它返回3，否则返回其输入值加2。修改smallest_divisor函数，让它用next(test_divisor)而不是test_divisor+1。请用结合了这一smallest_divisor版本的timed_prime_test运行练习1.22里那个找12个素数的测试。这样修改使检查的次数减半，你可能期望其运行速度快一倍。实际情况符合这一预期吗？如果不符，你观察到的两个算法速度的比值是什么？你如何解释比值不是2的事实？

## 解答
* 实际执行时间为[0,2,5,11]，对比上一节[0,2,7,16]，比值小于2，约为1.5倍。
* 对比两版代码，唯一差异在于 一次加法 对比 ifelse(同样包含一次加法)语句，ifelse新增逻辑增加了用时。
* 代码参见上一节。