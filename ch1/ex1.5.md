# 1.1.6 条件表达式和谓词
## 题目1.5
 Ben Bitdiddle发明了一种检测方法，能用于确定解释器究竟采用哪种求值序，是用应用序求值，还是用正则序求值。他声明了下面两个函数：
```javascript
function p() { return p(); }
function test(x, y) {
    return x === 0 ? 0 : y;
}
```
 而后他求值下面的语句：
```javascript
test(0, p());
```
 如果解释器采用应用序求值，Ben会看到什么样的情况？如果解释器采用正则序求值，他又会看到什么情况？请解释你的回答。​（在这里我们假设：无论解释器实际使用的是正则序还是应用序，条件表达式的求值规则总是一样的，其中的谓词部分先行求值，再根据其结果确定随后求值的子表达式部分。​）
## 解答
- > “完全展开而后归约”的求值模型称为正则序求值，与之相对的是解释器实际使用的方式，​“先求出实参而后应用”​，这称为应用序求值。
- 应用序求值，会看到无限递归，因为test的第二个参数p()会被无限次求值。
```rust
// 应用序,rust实际即为应用序
fn p() -> i32 {
    p()
} 
fn test(x: i32, y: i32) -> i32 {
    if x == 0 {
        0
    } else {
        y
    }
}

fn main() {
    // 这里会先求值 p()，导致无限递归
    let result = test(0, p());
    println!("{}", result);
}
```
- 正则序求值，会看到0，因为test的第二个参数p()不会被求值。
```rust
// 模拟正则序
fn p() -> i32 {
    p() // 无限递归
}

fn test(x: i32, y: impl Fn()->i32 ) -> i32
{
    if x == 0 {
        0
    } else {
        y()
    }
}

fn main() {
    let result = test(0,p);
    println!("{}", result); // 输出 0，因为 p() 不会被调用
}
```

